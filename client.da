import nacl.encoding
import nacl.signing
import nacl.hash
import json
class Client(process):
   def setup(clientId,workloadList,signingKey,config,logFilePath):
   	self.f = open(logFilePath + 'client_'+ str(clientId) + '.log','w')
   	self.requestSequenceList = []
   	self.replicaList = []
   	self.setupFlag = False
   	self.successflag = False
   	self.seqNo = 0
   	self.verifyKeyHexClientList= {}
   	self.verifyKeyHexReplicaList= {}
  	# Creating a list of operations.
   	createRequestSequenceList(workloadList)
   	self.f.write("\nClient - " + str(clientId) + " setup completed")

   def createRequestSequenceList(workloadList):
   	#if pseudorandom 
   	if 'pseudorandom' in workloadList:
   		self.f.write("I am pseudorandom")
		#handle this
   	else:
   		#put inidvidual requests in a list
   		self.requestSequenceList = workloadList.split(';')
   		#self.f.write(self.requestSequenceList)
   
   #msg from olympus
   def receive(msg=('setupClient',replica,verifyKeyHexClientList,verifyKeyHexReplicaList,)):
   	self.f.write("\nReceived replica list and public keys from olympus")
   	self.replicaList = replica
   	self.setupFlag = True
   	self.verifyKeyHexClientList=verifyKeyHexClientList
   	self.verifyKeyHexReplicaList=verifyKeyHexReplicaList

   #msg from tail replica
   def receive(msg=('Result',resultProof,result)):
   	self.successflag = True
   	self.f.write("\n\tReceived result from replica - " +  result)
   	self.f.write("\n\tChecking proof of misbehiour by checking signatures and hashes in result proof")
   	checkProofOfmisBehaviour(resultProof, result)

   def decryptReplicaRequest(signedStatement,replicaId):
        verify_key = nacl.signing.VerifyKey(self.verifyKeyHexReplicaList[replicaId], encoder=nacl.encoding.HexEncoder)
        data = verify_key.verify(signedStatement)
        return json.loads(data.decode('utf-8'))

   def checkProofOfmisBehaviour(resultProof, result):
   	resultStatement = resultProof["resultStatement"]
   	counter = 1
   	for r in resultStatement:
   		statement = decryptReplicaRequest(r,counter)
   		if(result != statement["value"]):
   			self.f.write("\n\t Proof of misbehaviour for request " + resultProof["operation"])
   			return
   		counter +=1
   	self.f.write("\n\tChecked all signatures and hashes present in result proof for operation " + resultProof["operation"])

   def retransmitRequest(request):
   	self.f.write("\nSending retransmit request to all replica for operation : " + request["operation"])
   	for replica in self.replicaList:
   		data = json.dumps(request)
   		signedRequest = signingKey.sign(bytes(data,'utf-8'))
   		send(('Retransmit',signedRequest,clientId), to=self.replicaList[0]["obj"])
   		if await(self.successflag == True):
   			self.f.write("\n\tReceived response for retransmission request for operation : "  + request["operation"] + "\n")
   		elif timeout(config["client_timeout"]):
   			self.f.write("\n\tTimeout for retransmission request for operation : " + request["operation"] + "\n")

   def sendRequest():
   	for operation in self.requestSequenceList:
   		self.f.write("\nSending request " + operation + " to head replica " + str(self.replicaList[0]["obj"]))
   		self.seqNo += 1
   		request = {}
   		request["seqNo"] = self.seqNo
   		request["operation"] = operation
   		request["clientId"] = clientId
   		self.successflag = False
   		data = json.dumps(request)
   		signedRequest = signingKey.sign(bytes(data,'utf-8'))
   		self.f.write("\n\tEncrypting request...")
   		send(('Request',signedRequest,clientId), to=self.replicaList[0]["obj"])
   		self.f.write("\n\tAwaiting for result....")
   		if await(self.successflag == True):
   			self.f.write("\n\tReceived response for request " + operation + "\n")
   		elif timeout(config["client_timeout"]):
   			self.f.write("\n\tTimeout for request " + operation + "\n")
   			retransmitRequest(request)

   def run():
   	self.f.write("\nRunning client Id - " +  str(clientId))
   	await(self.setupFlag == True)
   	sendRequest()
   	self.f.close()
